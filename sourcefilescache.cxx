/*
 * Copyright (C) 2021 Stoyan Shopov <stoyan.shopov@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "sourcefilescache.hxx"
#include "utils.hxx"
#include "cscanner.hxx"

std::shared_ptr<const struct SourceFilesCache::SourceFileCacheData> SourceFilesCache::getSourceFileCacheData(const QString &sourceFileName, QString & errorMessage)
{
	errorMessage.clear();
	QFileInfo fi(sourceFileName);
	QFile f(sourceFileName);
	if (!fi.exists())
	{
		/* Attempt to adjust the filename path on windows systems. */
		fi.setFile(Utils::filenameToWindowsFilename(sourceFileName));
		f.setFileName(fi.absoluteFilePath());
	}
	if (fi.exists())
	{
		auto sourceData = sourceFileCacheData.find(sourceFileName);
		if (sourceData != sourceFileCacheData.end())
			if (sourceData.operator *()->lastModifiedDateTime == fi.lastModified())
				return sourceData.operator *();
		/* File was found, but it was probably modified. Attempt to reload the file */
		sourceFileCacheData.erase(sourceData);
	}

	if (!fi.exists())
	{
		errorMessage = QString("Cannot find file \"%1\"").arg(sourceFileName);
		return 0;
	}
	else if (!f.open(QFile::ReadOnly))
	{
		errorMessage = QString("Failed to open file \"%1\"").arg(sourceFileName);
		return 0;
	}

	yyscan_t scanner;
	std::string s;
	yylex_init_extra(& s, &scanner);

	yy_scan_string((f.readAll() + '\0').constData(), scanner);
	yylex(scanner);
	yylex_destroy(scanner);

	/* Prepend line numbers to the source code lines. */
	QList<QString> lines = QString::fromStdString(s).split('\n');
	int numFieldWidth = QString("%1").arg(lines.count()).length();
	QByteArray source =
			"<!DOCTYPE html>\n"
			"<html>\n"
			"<head>\n"
			"<meta charset=\"ISO-8859-1\">\n"
			"<title>Source file</title>\n"
			"<link rel=\"stylesheet\" type=\"text/css\" href=\":/resources/highlight.css\">\n"
			//"<link rel=\"stylesheet\" type=\"text/css\" href=\"highlight.css\">\n"
			"</head>\n"
			"<body class=\"hl\">\n"
			"<pre class=\"hl\">"
			;

	int lineNumber = 0;
	if (!sourceFileData.get() || sourceFileData->find(sourceFileName) == sourceFileData->cend()
		|| !sourceFileData->find(sourceFileName)->machineCodeLineNumbers.size())
		/* Do not add breakpoint markers. */
		for (const auto & l : lines)
			source += QString("%1 |%2\n").arg(++ lineNumber, numFieldWidth).arg(l);
	else
	{
		/* Add breakpoint markers. */
		const auto t = sourceFileData->find(sourceFileName)->machineCodeLineNumbers;
		for (const auto & l : lines)
			source += QString("%1%2 |%3\n").arg(t.count(++ lineNumber) ? '*' : ' ').arg(lineNumber, numFieldWidth).arg(l);
	}

	source +=
			"</pre>\n"
			"</body>\n"
			"</html>\n"
			"<!--HTML generated by XXX: todo - put an appropriate reference here-->"
			;

	std::shared_ptr<struct SourceFileCacheData> sourceData = std::make_shared<struct SourceFileCacheData>();
	sourceData->filesystemFileName = f.fileName();
	sourceData->lastModifiedDateTime = fi.lastModified();
	sourceData->htmlDocument = std::make_shared<const QString>(source);
	sourceData->sourceCodeTextlines = QString((f.seek(0), f.readAll())).split('\n');
	sourceFileCacheData.operator [](sourceFileName) = sourceData;
	return sourceData;
}
